# 字典序全排列算法 #
非递归方法（字典序法）：<br/>
对给定的字符集中的字符规定了一个先后关系，在此基础上规定两个全排列的先后是从左到右逐个比较对应的字符的先后。

    [例]字符集{1,2,3},较小的数字较先,这样按字典序生成的全排列是:
    　　123,132,213,231,312,321
※ 一个全排列可看做一个字符串，字符串可有前缀、后缀。<br/>
生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。<br/>

     [例]839647521是1--9的排列。1—9的排列最前面的是123456789，
      最后面的987654321，从右向左扫描若都是增的，就到了987654321，
      也就没有下一个了。否则找出第一次出现下降的位置。

 如何得到346987521的下一个

    从尾部往前找第一个P(i-1) < P(i)的位置
    3 4 6 <- 9 <- 8 <- 7 <- 5 <- 2 <- 1
    最终找到6是第一个变小的数字，记录下6的位置i-1
    2，从i位置往后找到最后一个大于6的数
    3 4 6 -> 9 -> 8 -> 7 5 2 1
    最终找到7的位置，记录位置为m
    3，交换位置i-1和m的值
    3 4 7 9 8 6 5 2 1
    4，倒序i位置后的所有数据
    3 4 7 1 2 5 6 8 9
    则347125689为346987521的下一个排列
代码实现

    <?php
    $str = '123456798';
    PermutationList($str);
    function PermutationList($str)
    {
    	$length = strlen($str);
    	$endIndex = $length-1;
      do{
      	$formIndex = $length-1;
      	//向前查找第一个变小的元素
      	while ($formIndex>0&&$str[$formIndex]>$str[$formIndex-1]) {
      		$formIndex--;
      	}
      	if($formIndex==0)break;
      	$changeIndex = $formIndex;
      	//向后查找第一个大于$str[$formIndex-1]的数
      	while ($changeIndex+1<$length&&$str[$changeIndex+1]>$str[$formIndex-1]) {
      		++$changeIndex;
      	}
      	swap($str, $formIndex-1, $changeIndex);
      	invertArray($str, $formIndex, $endIndex);//反向处理
      }while(true);
      print_r($str);
    }
    
    function swap(&$str,$a,$b)
    {
    	$temp = $str[$a];
    	$str[$a] = $str[$b];
    	$str[$b ]= $temp;
    }
    
    function invertArray(&$str, $formIndex, $endIndex){
      for (; $formIndex <$endIndex ; $formIndex++,$endIndex--) { 
      	 swap($str, $formIndex, $endIndex);
      }
    }