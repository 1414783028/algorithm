**Cracking the Coding Interview程序员面试金典**<br/>
**1.1 确定字符互异**<br/>
请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。<br/>
**思路**:基于快速排序的partition，可以边排序边找重复<br/>

**1.2 原串翻转**<br/>
请实现一个算法，在不使用额外数据结构和储存空间的情况下，翻转一个给定的字符串(可以使用单个过程变量)。<br/>

**1.3 确定两串乱序同构**<br/>
给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。这里规定大小写为不同字符，且考虑字符串重点空格。<br/>
**思路**:使用一个计数的数组来做<br/>

**1.4 空格替换**<br/>
请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。<br/>


**1.5 基本字符串压缩**<br/>
利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串“aabcccccaaa”经压缩会变成“a2b1c5a3”。若压缩后的字符串没有变短，则返回原先的字符串。<br/>
**思路**:定义一个字符串数组用来放存在的字符和相应字符的数量

**1.6 像素翻转**<br/>
有一副由NxN矩阵表示的图像，这里每个像素用一个int表示，请编写一个算法，在不占用额外内存空间的情况下(即不使用缓存矩阵)，将图像顺时针旋转90度。<br/>
**思路**: 
第一步：先将矩阵以次对角线互换 （如果是逆时针则为主对角线） <br/>
 第二步：交换第i行到第n-i-1行<br/>

**1.7 压缩空格**<br/>
要求时间复杂度O(N)空间复杂度O(1)<br/>
**思路**: 定义两个游标，如果当前不是空格就把该处的值赋值给前面

**1.8 清除行列**<br/>
请编写一个算法，若MxN矩阵中某个元素为0，则将其所在的行与列清零。<br/>
**思路**:首先找到需要变为0的行和列号，
记录在矩阵row和col中，若需要变为0则记为1，反之记为0，最后清零<br/>

**1.9  翻转子串**<br/>
假定我们都知道非常高效的算法来检查一个单词是否为其他字符串的子串。请将这个算法编写成一个函数，给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成，要求只能调用一次检查子串的函数。<br/>
**思路**:s1拼接自己一次当作s3，s2如果是s1旋转来的就必定是s3的子串
 
**2.0  求链表中倒数第k个数** <br/>
输入一个链表，输出该链表中倒数第k个结点。 <br/>
**思路**:第一次遍历链表，第一次求链表的长度length,第二次求第length-k+1个结点

**2.1 访问单个节点的删除** <br/>
实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。 <br/>

**2.2 链表分割** <br/>

编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前<br/>
**思路一**:小数链表和大数链表，最后完成后将两链表连接，注意头结点也有值<br/>
**思路二**:将链表的节点存放在数组中，进行快速排序的调整<br/>

**2.3 链式A加B** <br/>
有两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表的首部。编写函数对这两个整数求和，并用链表形式返回结果<br/>
**思路**：这里对于不同长度的数字，我们通过将较短的数字补0来保证每一位都能相加<br/> 

**2.4 回文链表**<br/> 
**思路一**：申请一个栈，将节点全部压入，遍历节点和弹出的节点对比<br/>
**思路二**：申请一个栈，用快指针和慢指针同时遍历，慢指针遍历时，将节点压入栈中，当快指针走完，慢指针在中间，整个调整过程实际上是把左边的节点折过来和右边的比较<br/>
**思路三**：找到中间节点，右边逆序调整，然后两头开始判断<br/>

**2.4.2 环形链表插值**<br/>
有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。给定链表的信息，及元素的值A及对应的nxt指向的元素编号同时给定val，请构造出这个环形链表，并插入该值
<br/>
**思路**：如果val大于头节点的值则更新头节点，如果是中间位置，则需要防止断链<br/>

**2.4.3 链表的k逆序**<br/>
有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1->2->3->4->5->6->7->8->null，K=3这个例子。调整后为，3->2->1->6->5->4->7->8->null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。<br/>
**思路一**:可以使用栈存储k个节点，然后依次弹出<br/>
**思路二**:不使用栈，但是需要前一次调整后的最后一个节点指针下一组需要调整的最后一个节点<br/>

**2.4.4 复杂链表的复制**<br/>
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）。<br/> 
**思路**：每个节点分别拷贝一个在其后面，然后让原来的和拷贝random指向相对应的节点,最后分离 <br/> 

**2.4.5  链表判环**<br/>
如何判断一个单链表是否有环？有环的话返回进入环的第一个节点的值，无环的话返回-1。如果链表的长度为N，请做到时间复杂度O(N)，额外空间复杂度O(1)。<br/> 
**思路**：快指针一次跳两个，如果为NULL，则没有环<br/>
有环时，当快指针和慢指针相遇时，让快指针等于头节点，
一次遍历一个,慢指针一次遍历一个，在进入环的第一个节点再次相遇<br/> 


**2.4.6 无环单链表判相交** <br/>
现在有两个无环单链表，若两个链表的长度分别为m和n，请设计一个时间复杂度为O(n + m)，额外空间复杂度为O(1)的算法，判断这两个链表是否相交<br/> 
**思路** 遍历两个链表得到长度，然后长链表先走差值，一样长时，再同步走，会同时到达相遇节点。<br/>
**扩展**: 有环单链表相交判断,单链表相交判断(注意结构,再结合链表判环和此题方法解即可)<br/>


**2.5 集合栈**<br/> 
请实现一种数据结构SetOfStacks，由多个栈组成，其中每个栈的大小为size，当前一个栈填满时，新建一个栈。该数据结构应支持与普通栈相同的push和pop操作。<br/>

**2.6 用两个栈实现队列**<br/>
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 <br/>
**思路**：进时，栈2是否为空，不为空，则栈2元素倒回到栈1，出时，将栈1元素全部弹到栈2中，直到栈1为空。<br/>

**2.7 双栈排序**<br/>
请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。<br/>
**思路**：把numbers中的一个个元素拿出比较，放入临时栈help中，如果新的元素比help中的小，
便把help中大的取出放入numbers中，压入小的进help,再把大的从numbers取出压入help。
最后把help全部元素放入numbers,返回numbers。

**2.8 猫狗收容所**<br/>
   有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫或狗），并收养该种动物中最早进入收容所的。  <br/>
**思路**：维护两个队列，一个队列存放放入的狗，一个队列存放放入的猫,每次把动物放入队列的时候，同时将一个递增的序号放入队列，这个序号就是一个时间序列<br/>

**2.9 位运算_交换**<br/>
请编写一个算法，不用任何额外变量交换两个整数的值<br/>
**思路** 结合率和交换率<br/>

**3.0 位运算_比较**<br/>
对于两个32位整数a和b，请设计一个算法返回a和b中较大的。但是不能用任何比较判断。若两数相同，返回任意一个。
给定两个整数a和b，请返回较大的数<br/>
**思路** 我们可以得到a-b的符号，根据该符号决定返回a或b<br/>

**3.1 位运算_寻找奇数出现**<br/>
有一个整型数组A，其中只有一个数出现了奇数次，其他的数都出现了偶数次，请打印这个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)。给定整形数组A及它的大小n，请返回题目所求数字。<br/>
**思路** 异或运算<br/>

**3.2位运算_寻找奇数出现2**<br/>
给定一个整型数组arr，其中有两个数出现了奇数次，其他的数都出现了偶数次，找到这两个数。要求时间复杂度为O(N)，额外空间复杂度为O(1)<br/>
**思路** <br/>
        比如出现奇数次的a,b<br/>
        定义eO=0遍历arr依次异或，结果为eO=a^b<br/>
        因为a、b互异，所有eO不等于0，设eO的第k位为1<br/>
        定义变量eOhasOne = 0;与arr中第k位为1的值进行依次异或，结果eOhasOne = a或eOhasOne =b<br/>
        通过eO^eOhasOne求得另外一个数<br/>

**3.3位运算_二进制插入**<br/>
有两个32位整数n和m，请编写算法将m的二进制数位插入到n的二进制的第j到第i位,其中二进制的位数从低位数到高位且以0开始<br/>
**思路** 用1011与1024的第j位到第i位做或运算（|）即可。
        可以让10011左移j位就可以正常做运算了<br/>


**3.4位运算_二进制小数**<br/>
有一个介于0和1之间的实数，类型为double，返回它的二进制表示。如果该数字无法精确地用32位以内的二进制表示，返回“Error”。<br/>
**思路** 乘二取整，顺序排列<br/>

