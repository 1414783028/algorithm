**Cracking the Coding Interview程序员面试金典**<br/>
**1.1 确定字符互异**<br/>
请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。<br/>
**思路**:基于快速排序的partition，可以边排序边找重复<br/>

**1.2 原串翻转**<br/>
请实现一个算法，在不使用额外数据结构和储存空间的情况下，翻转一个给定的字符串(可以使用单个过程变量)。<br/>

**1.3 确定两串乱序同构**<br/>
给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。这里规定大小写为不同字符，且考虑字符串重点空格。<br/>
**思路**:使用一个计数的数组来做<br/>

**1.4 空格替换**<br/>
请编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串有足够的空间存放新增的字符，并且知道字符串的真实长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。<br/>


**1.5 基本字符串压缩**<br/>
利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串“aabcccccaaa”经压缩会变成“a2b1c5a3”。若压缩后的字符串没有变短，则返回原先的字符串。<br/>
**思路**:定义一个字符串数组用来放存在的字符和相应字符的数量

**1.6 像素翻转**<br/>
有一副由NxN矩阵表示的图像，这里每个像素用一个int表示，请编写一个算法，在不占用额外内存空间的情况下(即不使用缓存矩阵)，将图像顺时针旋转90度。<br/>
**思路**: 
第一步：先将矩阵以次对角线互换 （如果是逆时针则为主对角线） <br/>
 第二步：交换第i行到第n-i-1行<br/>

**1.7 压缩空格**<br/>
要求时间复杂度O(N)空间复杂度O(1)<br/>
**思路**: 定义两个游标，如果当前不是空格就把该处的值赋值给前面

**1.8 清除行列**<br/>
请编写一个算法，若MxN矩阵中某个元素为0，则将其所在的行与列清零。<br/>
**思路**:首先找到需要变为0的行和列号，
记录在矩阵row和col中，若需要变为0则记为1，反之记为0，最后清零<br/>

**1.9  翻转子串**<br/>
假定我们都知道非常高效的算法来检查一个单词是否为其他字符串的子串。请将这个算法编写成一个函数，给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成，要求只能调用一次检查子串的函数。<br/>
**思路**:s1拼接自己一次当作s3，s2如果是s1旋转来的就必定是s3的子串
 
**2.0  求链表中倒数第k个数** <br/>
输入一个链表，输出该链表中倒数第k个结点。 <br/>
**思路**:第一次遍历链表，第一次求链表的长度length,第二次求第length-k+1个结点

**2.1 访问单个节点的删除** <br/>
实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。 <br/>

**2.2 链表分割** <br/>

编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前<br/>
**思路一**:小数链表和大数链表，最后完成后将两链表连接，注意头结点也有值<br/>
**思路二**:将链表的节点存放在数组中，进行快速排序的调整<br/>

**2.3 链式A加B** <br/>
有两个用链表表示的整数，每个结点包含一个数位。这些数位是反向存放的，也就是个位排在链表的首部。编写函数对这两个整数求和，并用链表形式返回结果<br/>
**思路**：这里对于不同长度的数字，我们通过将较短的数字补0来保证每一位都能相加<br/> 

**2.4 回文链表**<br/> 
**思路一**：申请一个栈，将节点全部压入，遍历节点和弹出的节点对比<br/>
**思路二**：申请一个栈，用快指针和慢指针同时遍历，慢指针遍历时，将节点压入栈中，当快指针走完，慢指针在中间，整个调整过程实际上是把左边的节点折过来和右边的比较<br/>
**思路三**：找到中间节点，右边逆序调整，然后两头开始判断<br/>

**2.4.2 环形链表插值**<br/>
有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。给定链表的信息，及元素的值A及对应的nxt指向的元素编号同时给定val，请构造出这个环形链表，并插入该值
<br/>
**思路**：如果val大于头节点的值则更新头节点，如果是中间位置，则需要防止断链<br/>

**2.4.3 链表的k逆序**<br/>
有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1->2->3->4->5->6->7->8->null，K=3这个例子。调整后为，3->2->1->6->5->4->7->8->null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。<br/>
**思路一**:可以使用栈存储k个节点，然后依次弹出<br/>
**思路二**:不使用栈，但是需要前一次调整后的最后一个节点指针下一组需要调整的最后一个节点<br/>

**2.5 集合栈**<br/> 
请实现一种数据结构SetOfStacks，由多个栈组成，其中每个栈的大小为size，当前一个栈填满时，新建一个栈。该数据结构应支持与普通栈相同的push和pop操作。<br/>

**2.6 用两个栈实现队列**<br/>
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 <br/>
**思路**：进时，栈2是否为空，不为空，则栈2元素倒回到栈1，出时，将栈1元素全部弹到栈2中，直到栈1为空。<br/>

**2.7 双栈排序**<br/>
请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。<br/>
**思路**：把numbers中的一个个元素拿出比较，放入临时栈help中，如果新的元素比help中的小，
便把help中大的取出放入numbers中，压入小的进help,再把大的从numbers取出压入help。
最后把help全部元素放入numbers,返回numbers。

**2.8 猫狗收容所**<br/>
   有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式，第一种为直接收养所有动物中最早进入收容所的，第二种为选择收养的动物类型（猫或狗），并收养该种动物中最早进入收容所的。  <br/>
**思路**：维护两个队列，一个队列存放放入的狗，一个队列存放放入的猫,每次把动物放入队列的时候，同时将一个递增的序号放入队列，这个序号就是一个时间序列。<br/>